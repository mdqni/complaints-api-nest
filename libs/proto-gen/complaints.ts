// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.20.3
// source: complaints.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Category } from "./categories";

export const protobufPackage = "complaints";

export interface CreateComplaintRequest {
  title: string;
  barcode: string;
  categoryId: string;
  description: string;
}

export interface GetComplaintRequest {
  id: string;
}

export interface ListComplaintsRequest {
  page: number;
  limit: number;
}

export interface Complaint {
  id: string;
  title: string;
  barcode: string;
  categoryId: string;
  category: Category | undefined;
  description: string;
  status: string;
  createdAt: string;
  updatedAt: string;
}

export interface ComplaintResponse {
  complaint: Complaint | undefined;
}

export interface ListComplaintsResponse {
  complaints: ComplaintResponse[];
}

export const COMPLAINTS_PACKAGE_NAME = "complaints";

function createBaseCreateComplaintRequest(): CreateComplaintRequest {
  return { title: "", barcode: "", categoryId: "", description: "" };
}

export const CreateComplaintRequest: MessageFns<CreateComplaintRequest> = {
  encode(message: CreateComplaintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.barcode !== "") {
      writer.uint32(18).string(message.barcode);
    }
    if (message.categoryId !== "") {
      writer.uint32(26).string(message.categoryId);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateComplaintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateComplaintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.barcode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetComplaintRequest(): GetComplaintRequest {
  return { id: "" };
}

export const GetComplaintRequest: MessageFns<GetComplaintRequest> = {
  encode(message: GetComplaintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetComplaintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetComplaintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListComplaintsRequest(): ListComplaintsRequest {
  return { page: 0, limit: 0 };
}

export const ListComplaintsRequest: MessageFns<ListComplaintsRequest> = {
  encode(message: ListComplaintsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListComplaintsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComplaintsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseComplaint(): Complaint {
  return {
    id: "",
    title: "",
    barcode: "",
    categoryId: "",
    category: undefined,
    description: "",
    status: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const Complaint: MessageFns<Complaint> = {
  encode(message: Complaint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.barcode !== "") {
      writer.uint32(26).string(message.barcode);
    }
    if (message.categoryId !== "") {
      writer.uint32(34).string(message.categoryId);
    }
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(42).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Complaint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplaint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.barcode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseComplaintResponse(): ComplaintResponse {
  return { complaint: undefined };
}

export const ComplaintResponse: MessageFns<ComplaintResponse> = {
  encode(message: ComplaintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.complaint !== undefined) {
      Complaint.encode(message.complaint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplaintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplaintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.complaint = Complaint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListComplaintsResponse(): ListComplaintsResponse {
  return { complaints: [] };
}

export const ListComplaintsResponse: MessageFns<ListComplaintsResponse> = {
  encode(message: ListComplaintsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.complaints) {
      ComplaintResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListComplaintsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComplaintsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.complaints.push(ComplaintResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface ComplaintsServiceClient {
  createComplaint(request: CreateComplaintRequest): Observable<ComplaintResponse>;

  getComplaintById(request: GetComplaintRequest): Observable<ComplaintResponse>;

  listComplaints(request: ListComplaintsRequest): Observable<ListComplaintsResponse>;
}

export interface ComplaintsServiceController {
  createComplaint(
    request: CreateComplaintRequest,
  ): Promise<ComplaintResponse> | Observable<ComplaintResponse> | ComplaintResponse;

  getComplaintById(
    request: GetComplaintRequest,
  ): Promise<ComplaintResponse> | Observable<ComplaintResponse> | ComplaintResponse;

  listComplaints(
    request: ListComplaintsRequest,
  ): Promise<ListComplaintsResponse> | Observable<ListComplaintsResponse> | ListComplaintsResponse;
}

export function ComplaintsServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createComplaint", "getComplaintById", "listComplaints"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ComplaintsService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ComplaintsService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const COMPLAINTS_SERVICE_NAME = "ComplaintsService";

export type ComplaintsServiceService = typeof ComplaintsServiceService;
export const ComplaintsServiceService = {
  createComplaint: {
    path: "/complaints.ComplaintsService/CreateComplaint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateComplaintRequest): Buffer =>
      Buffer.from(CreateComplaintRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateComplaintRequest => CreateComplaintRequest.decode(value),
    responseSerialize: (value: ComplaintResponse): Buffer => Buffer.from(ComplaintResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ComplaintResponse => ComplaintResponse.decode(value),
  },
  getComplaintById: {
    path: "/complaints.ComplaintsService/GetComplaintById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetComplaintRequest): Buffer => Buffer.from(GetComplaintRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetComplaintRequest => GetComplaintRequest.decode(value),
    responseSerialize: (value: ComplaintResponse): Buffer => Buffer.from(ComplaintResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ComplaintResponse => ComplaintResponse.decode(value),
  },
  listComplaints: {
    path: "/complaints.ComplaintsService/ListComplaints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListComplaintsRequest): Buffer =>
      Buffer.from(ListComplaintsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListComplaintsRequest => ListComplaintsRequest.decode(value),
    responseSerialize: (value: ListComplaintsResponse): Buffer =>
      Buffer.from(ListComplaintsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListComplaintsResponse => ListComplaintsResponse.decode(value),
  },
} as const;

export interface ComplaintsServiceServer extends UntypedServiceImplementation {
  createComplaint: handleUnaryCall<CreateComplaintRequest, ComplaintResponse>;
  getComplaintById: handleUnaryCall<GetComplaintRequest, ComplaintResponse>;
  listComplaints: handleUnaryCall<ListComplaintsRequest, ListComplaintsResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
